1. В компонент передаются атрибуты `description` и `title` . Могу ли я их сложить как на примере, чтобы получить одну строку и вывести в компоненте?
    ```jsx
    import React from "react";
    import styles from './button.css'
    export default class Example extends React.Component {
        render() {
    				let {description,title} = this.props
    				title += description; //title = title + description
             return (
                <span>{title}</span>
            );
        }
    }
    ```

сложить атрибуты можно, и еще так перезапишется значение title

2. С помощью какого метода можно отловить изменение `props`?
componentDidUpdate()

3. Оператор расширения часто используется также для клонирования объекта. Подумайте, чем отличаются эти две записи и какую проблему решает здесь оператор расширения:

    ```jsx
    const initialObj = { title:'Hello', text:'World' }

    //№1
    const firstObj = initialObj

    //№2
    const secondObj = {...initialObj}
    ```
вариант №1 содержит ссылку на данные { title:'Hello', text:'World' } в месте их первоначального расположения, если эти сведения изменятся, мы увидим эти изменения и в firstObj.
вариант №2 создаст новый объект такого же содержания, как initialObj и будет хранить ссылку на этот новый объект, и если в initialObj изменится содержание, оно не изменится в secondObj

4. В каком из методов жизненного цикла лучше всего использовать методы вызова API и обращения к веб-хранилищам, если они должны быть вызваны всего один раз при загрузке страницы?
componentDidMount()

5. С помощью какого метода можно отловить и отрисовать для пользователя возникшую в компоненте ошибку?
componentDidCatch()

6. Какой код обычно пишут в конструкторе? Для каких задач он используется?
Конструкторы — это специальная функция, вызывается при создании нового экземпляра класса. в конструкторе вызывается функция super обеспечивающая неследованиео от родительского класса, объявляются все свойства объекта, устанавливается состояние и пропс.

7. Что делает функция `render`()? Что может её вызвать?
render() это метод в React-компонентах, который определяет, как компонент должен выглядеть на странице.
может быть вызван:
Инициализацией компонента (первоначальная отрисовка).
Обновлением состояния или props (перерировка в соответствии с новыми данными).
Форсированным вызовом forceUpdate() (принудительная перерировка даже если состояние или props не изменились, не рекомендуется).

8. Что нужно изменить в коде из урока (видео), чтобы начальные параметры у компонента приходили из пропсов, но если пропсы вообще не заданы, начальные значения были инициализированы нулями?
добавить значения по умолчанию и/или условную проверку

9. Можно ли несколько раз использовать хук `useEffect` внутри одного компонента?
да, можно.
Можно использовать его для имитации разных методов:
componentDidMount (первым аргументом передаём функцию, а вторым — пустой массив),
componentDidUpdate (первым аргументом передаём функцию, а вторым - параметры при изменении которых вызывать функцию) - можно использовать несколько раз, для каждого параметра
componentWillUnmount (вернуть (через return) функцию в теле эффекта, а вторым аргументом передать пустой массив).
Можно объединить:
useEffect(() => {
		console.log("it's as if componentDidMount");
		return () => {
     console.log("just like componentWillUnmount");
		};
}, [])

10. Можно ли не передавать второй аргумент в хук `useEffect`? Что тогда произойдёт?
Да, можно тогда он будет запускаться при каждом обновлении компонента, как componentDidUpdate, это может привести к частым вызовам.

11. Что означает возвращение функции в теле хука `useEffect`?
возвращенная функция выполнится аналогично использованию метода componentWillUnmount(). Эта функция выполнится перед запуском следующего эффекта или перед удалением компонента.

12. Будут ли перерисованы дочерние элементы компонента при вызове метода `forceUpdate`()?
Вызов forceUpdate() приведёт к выполнению метода render() в компоненте, пропуская shouldComponentUpdate().
Это вызовет обычные методы жизненного цикла для дочерних компонентов, включая shouldComponentUpdate() каждого дочернего компонента. То есть, дочерние элементы будут перерисованы только если для них произошли изменения.